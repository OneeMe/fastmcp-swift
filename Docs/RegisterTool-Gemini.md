# Macro-based Registration Design: @RegisterTool

This document outlines the design for a tool auto-registration mechanism using Swift Macros and a Build Tool Plugin.

## 1. Goals

- **Simplify Registration**: Developers should only need to attach the `@RegisterTool` macro to a type conforming to `MCPTool` to complete the registration, without any manual boilerplate code.
- **Decouple Dependencies**: The implementation code for a tool should only depend on the `FastMCPProtocol` module, not the `FastMCPSwift` core implementation.
- **Automatic Discovery**: The `FastMCPSwift` service should automatically discover and initialize all tools marked with `@RegisterTool` upon startup.

## 2. Core Challenge: Automatic Tool Discovery

In Swift, there is no built-in runtime mechanism to get a list of all types that conform to a specific protocol or are annotated with a certain macro. A macro can only transform the code it's attached to; it has no knowledge of other types that are also using the same macro.

Therefore, a pure macro-based solution is insufficient for automatic discovery. We need a mechanism that can scan the entire project's source code at compile time. The **SwiftPM Build Tool Plugin** is the perfect tool for this job.

## 3. Design: Macro + Build Tool Plugin

We will combine an **Attached Macro** with a **Build Tool Plugin** to achieve our goal.

### 3.1. The `@RegisterTool` Macro

We will create an attached macro named `@RegisterTool`.

- **Type**: Attached Macro.
- **Purpose**:
    1.  It acts as a marker, allowing the build plugin to identify which types need to be registered.
    2.  (Optional) It could add common boilerplate to the annotated type, such as conformance to an internal marker protocol. However, its primary role is to be an anchor for the scanner.

```swift
// Macro definition (in a new FastMCPMacro module)
@attached(member, names: named(init))
public macro RegisterTool() = #externalMacro(module: "FastMCPMacroImpl", type: "RegisterToolMacro")
```

### 3.2. The `ToolRegistry` (in `FastMCPProtocol`)

To manage the registered tools, we will define a simple registry within the `FastMCPProtocol` module.

```swift
// Defined in the FastMCPProtocol module
public protocol MCPTool {
    init()
    // ... other methods and properties required for a tool
}

public final class ToolRegistry {
    public static let shared = ToolRegistry()
    private var toolTypes: [String: MCPTool.Type] = [:]

    private init() {}

    public func register(_ toolType: MCPTool.Type) {
        let toolName = String(describing: toolType)
        print("Registering tool: \(toolName)")
        self.toolTypes[toolName] = toolType
    }

    public func allTools() -> [MCPTool.Type] {
        return Array(toolTypes.values)
    }
}
```

### 3.3. The Build Tool Plugin (`FastMCPBuildToolPlugin`)

This is the core of the auto-discovery mechanism.

1.  **Plugin Type**: `BuildToolPlugin`.
2.  **Trigger**: It runs when a target that depends on it is being built.
3.  **Workflow**:
    - The plugin uses `SwiftSyntax` to parse all Swift source files of the target.
    - It searches for all `struct` or `class` declarations annotated with the `@RegisterTool` macro.
    - For each type it finds, it records the type's name.
    - After scanning all files, the plugin generates a new Swift file (e.g., `_FastMCP_Generated_Tools.swift`).
    - The content of this generated file will look something like this:

    ```swift
    // !!! DO NOT EDIT !!!
    // This file is generated by FastMCPBuildToolPlugin.

    import FastMCPProtocol
    // May need to import other modules where tools are defined
    import MyProjectTools 

    public func registerAllDiscoveredTools() {
        ToolRegistry.shared.register(EchoTool.self)
        ToolRegistry.shared.register(WeatherTool.self)
        // ... registration calls for all other discovered tools
    }
    ```

### 3.4. Runtime Integration

The main `FastMCPSwift` application only needs to call this auto-generated function at startup.

```swift
// In the main entry point of FastMCPSwift
import FastMCPProtocol

@main
struct Server {
    static func main() {
        print("Server starting...")
        
        // Call the auto-generated function to register all tools
        registerAllDiscoveredTools()
        
        // ... subsequent startup logic. The ToolRegistry now contains all tools.
        let registeredTools = ToolRegistry.shared.allTools()
        print("\(registeredTools.count) tools have been registered.")

        // ...
    }
}
```

## 4. Module Dependencies

To implement this design, the project structure will include these key modules:

1.  `FastMCPProtocol`:
    - Defines the `MCPTool` protocol and `ToolRegistry`.
    - Has no other dependencies.

2.  `FastMCPMacro`:
    - Defines the `@RegisterTool` macro.
    - Depends on `SwiftSyntax` and `SwiftCompilerPlugin`.

3.  `FastMCPBuildToolPlugin`:
    - Implements the build plugin logic.
    - Depends on `PackagePlugin`.

4.  **Tool Definition Module** (e.g., `MyTools`):
    - Defines concrete tools like `EchoTool`.
    - Depends on `FastMCPProtocol` and `FastMCPMacro`.

5.  `FastMCPSwift` (Main Application):
    - The main application logic.
    - Depends on `FastMCPProtocol` and the **Tool Definition Module**.
    - Applies the `FastMCPBuildToolPlugin` to its own target in its `Package.swift` file.

## 5. Usage Example

For a developer to create a new `EchoTool`, they would simply:

1.  Ensure their target depends on `FastMCPProtocol` and `FastMCPMacro`.
2.  Write the following code:

```swift
import FastMCPProtocol
import FastMCPMacro

@RegisterTool
struct EchoTool: MCPTool {
    init() {}
    
    func handle(request: String) -> String {
        return "echo: " + request
    }
}
```

That's it. When the project is compiled, `EchoTool` will be automatically included in the `registerAllDiscoveredTools` function.

## 6. Summary

This approach provides an elegant solution for automatic tool discovery and registration by combining macros and build plugins. It promotes low coupling between modules and aligns with modern Swift development practices.